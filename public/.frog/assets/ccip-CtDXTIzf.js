import{s as p,A as E,t as k,f as O,b as L,d as x,B as l,h as b,i as w,j as h,I as m,k as A,l as M,m as P,H as y,n as R}from"../main.js";const S={inputs:[{name:"message",type:"string"}],name:"Error",type:"error"},$={inputs:[{name:"reason",type:"uint256"}],name:"Panic",type:"error"};function D(a){const{abi:r,data:t}=a,s=p(t,0,4);if(s==="0x")throw new E;const e=[...r||[],S,$].find(n=>n.type==="error"&&s===k(O(n)));if(!e)throw new L(s,{docsPath:"/docs/contract/decodeErrorResult"});return{abiItem:e,args:"inputs"in e&&e.inputs&&e.inputs.length>0?x(e.inputs,p(t,4)):void 0,errorName:e.name}}class j extends l{constructor({callbackSelector:r,cause:t,data:s,extraData:i,sender:e,urls:n}){super(t.shortMessage||"An error occurred while fetching for an offchain result.",{cause:t,metaMessages:[...t.metaMessages||[],t.metaMessages?.length?"":[],"Offchain Gateway Call:",n&&["  Gateway URL(s):",...n.map(d=>`    ${b(d)}`)],`  Sender: ${e}`,`  Data: ${s}`,`  Callback selector: ${r}`,`  Extra data: ${i}`].flat()}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupError"})}}class v extends l{constructor({result:r,url:t}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${b(t)}`,`Response: ${w(r)}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupResponseMalformedError"})}}class C extends l{constructor({sender:r,to:t}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${t}`,`OffchainLookup sender address: ${r}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"OffchainLookupSenderMismatchError"})}}function I(a,r){if(!h(a,{strict:!1}))throw new m({address:a});if(!h(r,{strict:!1}))throw new m({address:r});return a.toLowerCase()===r.toLowerCase()}const H="0x556f1830",T={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function N(a,{blockNumber:r,blockTag:t,data:s,to:i}){const{args:e}=D({data:s,abi:[T]}),[n,d,o,c,f]=e;try{if(!I(i,n))throw new C({sender:n,to:i});const u=await F({data:o,sender:n,urls:d}),{data:g}=await A(a,{blockNumber:r,blockTag:t,data:M([c,P([{type:"bytes"},{type:"bytes"}],[u,f])]),to:i});return g}catch(u){throw new j({callbackSelector:c,cause:u,data:s,extraData:f,sender:n,urls:d})}}async function F({data:a,sender:r,urls:t}){let s=new Error("An unknown error occurred.");for(let i=0;i<t.length;i++){const e=t[i],n=e.includes("{data}")?"GET":"POST",d=n==="POST"?{data:a,sender:r}:void 0;try{const o=await fetch(e.replace("{sender}",r).replace("{data}",a),{body:JSON.stringify(d),method:n});let c;if(o.headers.get("Content-Type")?.startsWith("application/json")?c=(await o.json()).data:c=await o.text(),!o.ok){s=new y({body:d,details:c?.error?w(c.error):o.statusText,headers:o.headers,status:o.status,url:e});continue}if(!R(c)){s=new v({result:c,url:e});continue}return c}catch(o){s=new y({body:d,details:o.message,url:e})}}throw s}export{F as ccipFetch,N as offchainLookup,T as offchainLookupAbiItem,H as offchainLookupSignature};
